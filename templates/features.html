<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Features</title>
    <style>
        body{
            background-image: linear-gradient( 109.6deg, rgba(156,252,248,1) 11.2%, rgba(110,123,251,1) 91.1% );
            }
        h1 {
        text-align: center;
            font-size:50px; font-weight:600; color:#222; letter-spacing:1px;
            text-transform: uppercase;

            display: grid;
            grid-template-columns: 1fr max-content 1fr;
            grid-template-rows: 27px 0;
            grid-gap: 20px;
            align-items: center;
        }

        h1:after,h1:before {
            content: " ";
            display: block;
            border-bottom: 1px solid #c50000;
            border-top: 1px solid #c50000;
            height: 5px;
          background-color:#f8f8f8;
        }

        h2 {background-color: #050847; color: #fff; font-family: 'Source Sans Pro', sans-serif; font-size: 30px; font-weight: 400; line-height: 32px; margin: 0 0 24px; }
        h3 {color: 'black'; font-family: 'Raleway',sans-serif; font-size: 25px; font-weight: 800; line-height: 36px; margin: 0 0 24px;}
        p { color: 'black'; font-family: 'Source Sans Pro', sans-serif; font-size: 18px; line-height: 32px; margin: 0 0 24px; }
        #hp  {
            float: right;
             margin: 0 0 0 15px;
        }
    </style>
</head>
<body>

<h1>Features</h1>

<h2>The Features of PE file that are used to differentiate between malware and legitimate file</h2>
<img src="{{ url_for('static', filename='uploader/pie.png')}}" style="width:650px;height:480px;" id="hp"/>
<h3>Entropy</h3>
<p>Entropy can be defined as measure of efficiency of information storage . It is directly related to the packing of the file, and packed file will have high entropy resulting in high efficiency of information storage. The pefile module has one method named get-entropy() that calculates entropy of a given section data. The result of this method is in the form of a quantity of bits per byte and so the maximum entropy will be 8:0. With the inherent properties of measuring the degree of compression, entropy is a very reliable feature to check packer and malicious behavior. Some modern malware or malicious packers try to reduce entropy by inserting zero bytes in data. It avoids detection, as many AV software only react to high entropy files. The entropy of different section of PE and whole file are also calculated and treated as features. As malware have many different names for different sections, only standard section names are considered as the feature and if section’s name is present then their respective entropy are added to the feature set, else ’-1’ is assigned as entropy value. In total, three features (E-text, E-data, E-file) are used based on entropy values. have used section’s entropy with threshold values 7 and 1 to set value for two boolean features HighEntropy and LowEntropy respectively. If any section of the corresponding PE file has entropy greater than 7 then HighEntropy is set to 1. When the entropy is less than 1, LowEntropy is set to 1. </p>
<h3>File Creation </h3>
<p>File Creation Year or Compilation time is very useful in identification of the malware from the benign program. Malware usually has very suspicious year of creation such as years earlier than 1980 or year beyond the current year, whereas the benign programs have very genuine year of creation. 1980 is considered as a starting year because the first DOS operating system was launched5 in this year. File creation year can be calculated using TimeDateStamp field value of File header for a given PE file. The calculated file creation year is checked within the valid range of year i.e. 1980–2015, if the year is within the range, then 1 is assigned as feature value else 0 is assigned indicating that the sample has a suspicious year of creation. </p>
<h3>Suspicious Section Name</h3>
<p>Suspicious Section Name is also a very good indicator of malicious file. A standard compiler gives well-defined name to each section like .data, .text, .rdata, etc. It has been observed that, the PE files built using certain nonstandard tools tend to have random section names. These types of sections are termed as suspicious. Section names of each sample is extracted using sections field value of PE header and these sections name are compared with a set of standard section name , count of match and non-matching section are assigned to two different feature variables TotalSuspiciousSections and TotalNonSuspiciousSections. </p>
<h3>UDP Destination Address</h3>
<p>UDP Destination Address most malwares try to connect to a remote server, either to transfer data or to establish a reverse shell. The number of UDP destination addresses can very effectively differentiate a malware from a benign executable, as malware are likely to make more UDP calls. </p>
<h3>Packer Info</h3>
<p>Packer Info would be a potential indicator of malware and benign program because, in our analysis, it is found that nearly 18benign samples. Both benign and malware can be packed but for different purposes. Benign programs are being packed to protect copyright and license key breaking attempt and also to stop reverse engineering of programs. Attackers pack their programs to bypass the signature-based detection because packed file changes the byte structure of program and it becomes easy to surpass the signature. Packer is a Boolean feature and will have 0 if file is not packed and 1 if packed with any packer. Packer information of each sample is collected using PEiD6 signature database with yara7 (a Python module for signature matching).</p>
<h3>File size</h3>
<p>File size is also used as a feature. We had initial assumption that malware file and benign programs file size will have a large difference. Malware writers try to keep file size minimum which helps them to distribute it over web hiding within another program. Malware samples result smaller in size due to avoidance of Graphical User Interface (GUI). Benign programs are free from such size requirement and have genuine size as needed. All libraries and external resources are used as needed to run the program efficiently and effectively. Malware writers truncate the unused function and other external resources from their malicious program, leaving selective API functions and DLL within programs.</p>
<h3>FileInfo</h3>
<p>FileInfo has set of strings, which contains the metadata about the PE file such as FileVersion, ProductVersion, ProductName, CompanyName, etc. Benign programs incorporate a rich metadata while malware writers avoid putting metadata. Metadata information of all samples are tried to extract but it is found that many of malware samples do not have FileInfo field or other subsection of this field. Set of all extracted strings about metadata are large so it is not feasible to consider these strings as features instead of that FileInfo feature is considered as Boolean and 1 is assigned if a sample has FileInfo metadata else 0. A more comprehensive feature set of metadata information can be considered but is limited to the presence and absence of the FileInfo metadata apart from its value. </p>
<h3>ImageBase </h3>
<p>ImageBase is a field in the optional header, which has the preferred address of the first byte of the image when loaded into memory . The condition applied to this field is that it must be a multiple of 64 k (641024). Default value for DLL is 0x10000000 (268435456 in decimal), Window CE exe is 0x00010000 (65536 in decimal) and 0x00400000 (4194304 in decimal) for other Windows OS like Windows XP. To make this field more useful, a pilot study is carried on the samples and it is found that 94:55only 77:84and all the value from both classes follow the condition of multiple of 64 K. Value of ImageBase field is very specific to type of file (DLL, exe etc.) So, malware authors do not tamper this field often which is clear from the aforementioned percentage. With the aforementioned result, it is decided to consider this field as Boolean and values were checked against for default values and multiple of 64. </p>
<h3>SectionAlignment</h3>
<p>SectionAlignment is another field in the optional header and it is the alignment (in bytes) of sections that determine when they are loaded into memory. According to the Microsoft specification it must be greater than or equal to FileAlignment and the default is the page size of the architecture. In the proposed work, this field is treated as Boolean and is compared against the specifications. If extracted value follows the specification then this field will have a value 1 else will be assigned as value 0. The value of FileAlignment field of optional header is the factor (in bytes) that is used to align the raw data of sections in the image file. Microsoft specification states that this value should be power of 2 (between 512 and 65536). Default value is 512 and if the SectionAlignment is less than the architecture’s page size, then this value must match with SectionAlignment value. </p>
<h3>SizeOfImage</h3>
<p>SizeOfImage gives the size (in bytes) of the image, including all headers, as the image is loaded in memory (Pietrek, 1994). It must be a multiple of SectionAlignment. This field is important to hide the embedded code. To verify this assumption, the specified condition is checked for malware and benign samples. It is found that almost all benign samples follow the specification but approx 4malware samples do not follow the specification. To benefit the classification process, since it got a significant proportion, this field is also considered as Boolean and assigned value 1 if it matches the specification otherwise 0. </p>
<h3>SizeOfHeaders</h3>
<p>SizeOfHeaders has value that is equal to the combined size of MS-DOS stub, PE header and Section headers, and is rounded to a multiple of FileAlignment. This specification is also validated for malware and benign samples. Among benign samples, 16not follow the specification while 78not follow the specification. This field is considered as Boolean and assigned 1 if extracted value follow the specification else 0 is assigned. The rationale for converting numeric values into boolean is to incorporate semantics in feature representation. For example, the feature CompilationTime holds TimeDateStamp which belongs to 32-bit Integer type. Moreover, binary representation would lead to simpler processing and build a robust classifier. The core idea of this approach is to harness the value of the field with respect to the context of malware identification. Similar logic is adopted for all other derived features.  representing a numeric value, the semantic of earliest file creation date is used as a delimiter to convert the value into boolean representation. Though this looks like losing som content in the original field, it provides an advantage of proper identification with respect to legitimate and tampered value. Moreover, binary representation would lead to simpler processing and build a robust classifier. The core idea of this approach is to harness the value of the field with respect to the context of malware identification. Similar logic is adopted for all other derived features. </p>

</body>
</html>